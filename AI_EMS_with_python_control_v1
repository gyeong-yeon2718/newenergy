#ì½”ë“œ ì„¤ëª…: AI EMSëŠ” t=0, 1, 2, ... ì‹œê°„ë§ˆë‹¤ ì‰ì—¬ì „ë ¥, ESS, H2 ì¶©ë°©ì „ì„ ê²°ì •í•˜ëŠ” 'ìš´ì˜ íŒë‹¨ ë¡œì§'ì„ ì‹œë®¬ë ˆì´ì…˜ í•©ë‹ˆë‹¤. 
ì´ ì½”ë“œëŠ” ê° ì‹œê°„ë³„ë¡œ ì‹œë®¬ë ˆì´ì…˜ í•  ë•Œ, ê·¸ ê²°ê³¼ê°€ 
phase 1 ì¸ì§€ phase 2ì¸ì§€ íŒë‹¨í•˜ì—¬ ì•„ë‘ì´ë…¸ ì°¨ëŸ‰ì—ê²Œ ì•/ë’¤/ì •ì§€ ì œì–´ ì‹ í˜¸ë¥¼ ë¸”ë£¨íˆ¬ìŠ¤ ëª¨ë“ˆë¡œ ë³´ë‚´ì£¼ëŠ” ì—­í• ì„ í•©ë‹ˆë‹¤.

# ==========================================================
# run_daily_sim.py (AI ì‹œë®¬ë ˆì´ì…˜)
# +
# arduino_control.py (ë¸”ë£¨íˆ¬ìŠ¤ ì°¨ëŸ‰ ì œì–´)
#
# AI ì‹œë®¬ë ˆì´ì…˜ ê²°ê³¼(Phase)ì— ë”°ë¼ ì•„ë‘ì´ë…¸ ì°¨ëŸ‰ì„ ì‹¤ì‹œê°„ ì œì–´
# ==========================================================

import pandas as pd
import serial  # (ì¶”ê°€) ì•„ë‘ì´ë…¸ ì œì–´ìš©
import time  # (ì¶”ê°€) ì‹¤ì‹œê°„ ì œì–´ìš©

# ===== (ì¶”ê°€) ì•„ë‘ì´ë…¸ ë¸”ë£¨íˆ¬ìŠ¤ ì„¤ì • =====
# (í•„ìˆ˜ ìˆ˜ì •!) PC ì¥ì¹˜ ê´€ë¦¬ìì—ì„œ í™•ì¸í•œ COM í¬íŠ¸
BLUETOOTH_PORT = "COM7"
BAUD_RATE = 9600

# (í•„ìˆ˜ ìˆ˜ì •!) ì‹œë®¬ë ˆì´ì…˜ 1ì‹œê°„(1 loop)ë‹¹ ëŒ€ê¸°í•  ì‹œê°„ (ì´ˆ)
# ì°¨ëŸ‰ì´ í•´ë‹¹ ë™ì‘(ì „ì§„/í›„ì§„)ì„ ìˆ˜í–‰í•  ì‹œê°„
TIME_PER_HOUR_SEC = 5.0


# ì•„ë‘ì´ë…¸ ëª…ë ¹ì–´ ì „ì†¡ í•¨ìˆ˜
def send_command(ser, command):
    """
    ì•„ë‘ì´ë…¸ë¡œ ëª…ë ¹ì–´ë¥¼ ì „ì†¡í•©ë‹ˆë‹¤. ('command\n' í˜•íƒœ)
    """
    try:
        command_with_newline = command + '\n'
        ser.write(command_with_newline.encode('utf-8'))
        print(f"[Arduino] Sent: {command}")
        time.sleep(0.1)  # ì „ì†¡ ì•ˆì •ì„±ì„ ìœ„í•œ ì§§ì€ ëŒ€ê¸°
    except Exception as e:
        print(f"[Arduino] Error sending command: {e}")


# ===== 0) íŒŒì¼ ê²½ë¡œ ì„¤ì • =====
RELATIVE_PATH = "ai_dataset_single_day.xlsx"
EXCEL_PATH = RELATIVE_PATH

# ===== 1) ë°ì´í„° ë¡œë“œ & ì „ì²˜ë¦¬ =====
try:
    df = pd.read_excel(EXCEL_PATH)
    print("ë°ì´í„° ë¡œë“œ ì™„ë£Œ")
    print(df.head())
except FileNotFoundError:
    print(f"ì˜¤ë¥˜: {EXCEL_PATH} íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    print("ìŠ¤í¬ë¦½íŠ¸ì™€ ê°™ì€ í´ë”ì— ì—‘ì…€ íŒŒì¼ì´ ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.")
    exit()  # íŒŒì¼ ì—†ìœ¼ë©´ ì¢…ë£Œ

# (ì´í•˜ ê¸°ì¡´ ì½”ë“œì™€ ë™ì¼)
required_cols = {"hour", "A_load_kWh", "B_load_kWh", "SMP_price", "surplus_kWh"}
missing = required_cols - set(df.columns)
b_load_avg = float(df["B_load_kWh"].mean())
b_load_max = float(df["B_load_kWh"].max())


# ===== 2) ê·œì¹™ê¸°ë°˜ AI í´ë˜ìŠ¤ (ê²½ì œì„± + ì¶©ì „í™•ëŒ€ + ì—°ì†ë°©ì „) =====
# (ì œê³µí•´ì£¼ì‹  í´ë˜ìŠ¤ ì½”ë“œ - ë³€ê²½ ì—†ìŒ)
class HybridEnergySystem:
    # ... (ì œê³µí•´ì£¼ì‹  í´ë˜ìŠ¤ ì½”ë“œ ì „ì²´) ...
    """
    Aë¶€í•˜(ì£¼íƒ), Bë¶€í•˜(ê³µì¥), ESS, ìˆ˜ì†Œì—°ë£Œì „ì§€ ê´€ë¦¬ + Phase1 ê²½ì œì„± ê³„ì‚°
    - ë‚® 10~15ì‹œ ì¶©ì „(ì‰ì—¬ì „ë ¥Ã—ë³´ì •)
    - Phase1 íŠ¸ë¦¬ê±° ì‹œ ì—°ì† ë°©ì „ ì„¸ì…˜(3ì‹œê°„)
    """

    def __init__(self,
                 initial_ess_soc=30.0,
                 initial_h2_storage=20.0,
                 ess_capacity_kwh=5000.0,  # 5MWh
                 charge_cost_won_per_kwh=110.0,
                 round_trip_eff=0.92,  # ì™•ë³µíš¨ìœ¨
                 min_margin_won_per_kwh=20.0,  # ìµœì†Œ ë§ˆì§„
                 session_length_hours=3):  # ì—°ì† ë°©ì „ ì‹œê°„(ì‹œê°„)
        # ìƒíƒœ
        self.ess_soc = float(initial_ess_soc)
        self.h2_storage = float(initial_h2_storage)
        self.H2_PCT_PER_HOUR_AT_RATED = 20.0  # ì •ê²© 1ì‹œê°„ ê°€ë™ ì‹œ íƒ±í¬ ì†Œëª¨ ë¹„ìœ¨(%)
        self.discharge_session = 0  # í˜„ì¬ ë‚¨ì€ ì—°ì† ë°©ì „ ì‹œê°„
        self.SESSION_LENGTH = int(session_length_hours)

        # íŒŒë¼ë¯¸í„°
        self.ESS_CAPACITY_KWH = float(ess_capacity_kwh)
        self.CHARGE_COST_WON_PER_KWH = float(charge_cost_won_per_kwh)
        self.ROUND_TRIP_EFF = float(round_trip_eff)
        self.MIN_MARGIN = float(min_margin_won_per_kwh)

        # ì„ê³„ì¹˜
        self.B_LOAD_PEAK_RATIO = 1.5
        self.SMP_PROFIT_THRESHOLD = 150
        self.ESS_PROFIT_THRESHOLD = 30

        # ì„¤ë¹„ ìŠ¤í™
        self.ESS_MAX_DISCHARGE_KW = 500  # ì‹œê°„ë‹¹ ìµœëŒ€ ë°©ì „ëŸ‰
        self.H2_FUEL_CELL_KW = 500

        # ê²½ì œì„± ëˆ„ì 
        self.cumulative_profit = 0.0

    # --- SoC% â†” kWh ë³€í™˜ ìœ í‹¸ ---
    def _soc_to_kwh(self) -> float:
        return (self.ess_soc / 100.0) * self.ESS_CAPACITY_KWH

    def _kwh_to_soc_delta(self, kwh: float) -> float:
        return (kwh / self.ESS_CAPACITY_KWH) * 100.0

    def charge_assets(self, current_time, surplus_power_kwh):
        """
        ë‚® 10~15ì‹œ: surplusë¡œ ì¶©ì „(ì›ê°€ 0) â€” surplus ë³´ì • ê³„ìˆ˜ ì ìš©
        ì‹¬ì•¼ 0~3ì‹œ: ìˆ˜ì†Œ ì €ì¥(ë°ëª¨ìš©)
        """
        action = "IDLE"
        revenue = 0.0
        cost = 0.0
        profit = 0.0

        # ì¶©ì „ êµ¬ê°„ í™•ëŒ€ + ë³´ì •ê³„ìˆ˜(Ã—3.0)
        if current_time in range(10, 16) and surplus_power_kwh > 0:
            ess_space_kwh = max(0.0, self.ESS_CAPACITY_KWH - self._soc_to_kwh())
            charge_kwh = min(ess_space_kwh, float(surplus_power_kwh) * 3.0)
            if charge_kwh > 0:
                self.ess_soc = min(100.0, self.ess_soc + self._kwh_to_soc_delta(charge_kwh))
                cost = 0.0  # ì‰ì—¬ ì „ë ¥ ì¶©ì „ì€ 0ì›
                action = f"ACTION: CHARGE_ESS +{charge_kwh:.1f}kWh (SoC: {self.ess_soc:.1f}%)"

        # ì‹¬ì•¼ ìˆ˜ì†Œ ì €ì¥(ê²½ì œì„±ì€ ì œì™¸)
        if current_time in [0, 1, 2, 3] and surplus_power_kwh > 0:
            self.h2_storage = min(80.0, self.h2_storage + surplus_power_kwh)
            action = f"ACTION: CHARGE_HYDROGEN (Storage: {self.h2_storage:.1f}%)"

        return action, revenue, cost, profit

    def _discharge_once(self, smp_price):
        """ì—°ì† ë°©ì „ 1ì‹œê°„ ìˆ˜í–‰(ë‚´ë¶€ í—¬í¼): ìˆ˜ìµ/ì´ìµ ê³„ì‚° ë° SoC ê°ì†Œ"""
        revenue = cost = profit = 0.0
        ess_energy_kwh = self._soc_to_kwh()
        discharge_kwh = min(self.ESS_MAX_DISCHARGE_KW, ess_energy_kwh)
        if discharge_kwh <= 0:
            return "IDLE (ESS ì”ëŸ‰ ë¶€ì¡±)", 0.0, 0.0, 0.0

        sellable_kwh = discharge_kwh * self.ROUND_TRIP_EFF
        revenue = sellable_kwh * float(smp_price)
        cost = 0.0  # surplus ì›ê°€ 0 ê°€ì •
        profit = revenue - cost

        self.ess_soc = max(0.0, self.ess_soc - self._kwh_to_soc_delta(discharge_kwh))
        self.cumulative_profit += profit
        return (f"[PHASE 1] ESS ë°©ì „ {discharge_kwh:.1f}kWh "
                f"(ìœ íš¨ {sellable_kwh:.1f}kWh, SoC {self.ess_soc:.1f}%)"), revenue, cost, profit

    def make_ai_decision(self, current_time, b_load_power, b_load_average, smp_price):
        revenue = cost = profit = 0.0

        # ì—°ì† ë°©ì „ ì„¸ì…˜ì´ ì§„í–‰ ì¤‘ì´ë©´ ê³„ì† ë°©ì „ (SMPê°€ ì•„ì£¼ ë‚®ì§€ ì•Šì€ í•œ)
        if self.discharge_session > 0:
            self.discharge_session -= 1
            msg, revenue, cost, profit = self._discharge_once(smp_price)
            return f"[PHASE 1-ì—°ì†ë°©ì „] {msg} (ì”ì—¬ {self.discharge_session}h)", revenue, cost, profit

        # Phase 2 (ë™ì¼)
        is_b_peak_detected = (b_load_power >= b_load_average * self.B_LOAD_PEAK_RATIO)
        if is_b_peak_detected:
            if b_load_power > self.ESS_MAX_DISCHARGE_KW:
                if self.h2_storage > 0:
                    # === ìˆ˜ì†Œ ì”ëŸ‰ ë°©ì „ ë°˜ì˜ (í¼ì„¼íŠ¸ ëª¨ë¸) ===
                    # ESSê°€ ì»¤ë²„ ëª»í•˜ëŠ” í•„ìš”ì „ë ¥(kW)
                    required_kw = b_load_power - self.ESS_MAX_DISCHARGE_KW
                    # ì—°ë£Œì „ì§€ í•œë„ ë‚´ì—ì„œ ê³µê¸‰
                    fc_kw = min(required_kw, self.H2_FUEL_CELL_KW)

                    if fc_kw > 0:
                        # 100% ìˆ˜ì†Œ = ì—°ë£Œì „ì§€ ì •ê²©(H2_FUEL_CELL_KW)ë¡œ 1ì‹œê°„ ê°€ë™í•œë‹¤ê³  ê°€ì •
                        needed_pct_hour = (fc_kw / self.H2_FUEL_CELL_KW) * self.H2_PCT_PER_HOUR_AT_RATED
                        use_pct = min(self.h2_storage, needed_pct_hour)

                        # ì‹¤ì œ ê³µê¸‰ ì „ë ¥ì€ ì‚¬ìš© í¼ì„¼íŠ¸ì— ë¹„ë¡€
                        supplied_kw = (use_pct / 100.0) * self.H2_FUEL_CELL_KW

                        # ìˆ˜ì†Œ ì”ëŸ‰ ì°¨ê°
                        self.h2_storage = max(0.0, self.h2_storage - use_pct)

                        return (f"[PHASE 2] Bë¶€í•˜ í”¼í¬ ê°ì§€! ì—°ë£Œì „ì§€ {supplied_kw:.1f}kW ê°€ë™ "
                                f"(H2 -{use_pct:.1f}% â†’ {self.h2_storage:.1f}%)",
                                revenue, cost, profit)
                    else:
                        return "[ERROR] Bë¶€í•˜ í”¼í¬ ê°ì§€! ì—°ë£Œì „ì§€ ì¶œë ¥ 0kW", revenue, cost, profit
                else:
                    return "[ERROR] Bë¶€í•˜ í”¼í¬ ê°ì§€! ì‚¬ìš©ê°€ëŠ¥í•œ ìˆ˜ì†Œ ì—†ìŒ!", revenue, cost, profit
            else:
                if self.ess_soc > (b_load_power / self.ESS_MAX_DISCHARGE_KW * 100):
                    return "[PHASE 1] Bë¶€í•˜ í”¼í¬ ê°ì§€. ESSë¡œ ëŒ€ì‘í•©ë‹ˆë‹¤.", revenue, cost, profit
                else:
                    return "[ERROR] Bë¶€í•˜ í”¼í¬ ê°ì§€! ESS ì”ëŸ‰ ë¶€ì¡±!", revenue, cost, profit

        # Phase 1 (ê²½ì œì„± íŠ¸ë¦¬ê±°)
        is_ess_ready = (self.ess_soc > self.ESS_PROFIT_THRESHOLD)
        is_smp_high = (smp_price > self.SMP_PROFIT_THRESHOLD)

        if is_ess_ready and is_smp_high:
            # ë°©ì „ ì„¸ì…˜ ì‹œì‘: í˜„ì¬ í¬í•¨ 1h + ì´í›„ (SESSION_LENGTH-1)h
            self.discharge_session = max(self.SESSION_LENGTH - 1, 0)
            msg, revenue, cost, profit = self._discharge_once(smp_price)
            return f"[PHASE 1-ì„¸ì…˜ì‹œì‘] {msg} (ì¶”ê°€ {self.discharge_session}h ì˜ˆì •)", revenue, cost, profit

        return "IDLE (Bë¶€í•˜ ì•ˆì •, SMP ë‚®ìŒ ë˜ëŠ” ESS ì”ëŸ‰ ë¶€ì¡±)", revenue, cost, profit


# ===== 3) ì‹œë®¬ë ˆì´ì…˜ ì„¤ì • =====
# (ê¸°ì¡´ ì½”ë“œì™€ ë™ì¼)
system = HybridEnergySystem(
    initial_ess_soc=30.0,
    initial_h2_storage=90.0,
    ess_capacity_kwh=5000.0,
    round_trip_eff=0.92,
    session_length_hours=3
)
FORCE_PHASE2_ONCE = True
if FORCE_PHASE2_ONCE:
    dynamic_ratio = (b_load_max / b_load_avg) * 0.98
    system.B_LOAD_PEAK_RATIO = dynamic_ratio
    print(f"âš™ï¸  B_LOAD_PEAK_RATIO ë™ì  ì„¤ì •: {dynamic_ratio:.3f} (ê¸°ë³¸ 1.500 â†’ ë™ì ê°’)")

# ===== (ìˆ˜ì •) 4) 24ì‹œê°„ ë£¨í”„ ì‹¤í–‰ + ì•„ë‘ì´ë…¸ ì œì–´ =====

logs = []
cum_profit = 0.0
ser = None  # ì‹œë¦¬ì–¼ ê°ì²´ ì´ˆê¸°í™”

try:
    # --- (ì¶”ê°€) ì•„ë‘ì´ë…¸ ë¸”ë£¨íˆ¬ìŠ¤ ì—°ê²° ---
    print(f"\n[Arduino] {BLUETOOTH_PORT} í¬íŠ¸ì— ì—°ê²° ì‹œë„ ì¤‘...")
    ser = serial.Serial(BLUETOOTH_PORT, BAUD_RATE, timeout=1)
    print("[Arduino] ì—°ê²° ì„±ê³µ!")
    time.sleep(2)  # ì•„ë‘ì´ë…¸ ë¶€íŠ¸ë¡œë” ëŒ€ê¸°
    send_command(ser, "stop")  # ì‹œì‘ ì‹œ ì •ì§€ ëª…ë ¹
    print("--- 24ì‹œê°„ ì‹œë®¬ë ˆì´ì…˜ ë° ì°¨ëŸ‰ ì œì–´ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤ ---")

    # --- ê¸°ì¡´ 24ì‹œê°„ ë£¨í”„ ---
    for _, r in df.iterrows():
        hour = int(r["hour"])
        surplus = float(r["surplus_kWh"])
        smp = float(r["SMP_price"])
        b_load = float(r["B_load_kWh"])

        print(f"\n--- [ {hour}ì‹œ ] ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘ ---")

        # (1) ì‰ì—¬ì „ë ¥ ì¶©ì „
        charge_action, ch_rev, ch_cost, ch_profit = system.charge_assets(hour, surplus)

        # (2) AI ìš´ì˜ íŒë‹¨
        decision, revenue, cost, profit = system.make_ai_decision(hour, b_load, b_load_avg, smp)

        # (3) (ì¶”ê°€) AI ê²°ì •(decision)ì„ íŒŒì‹±í•˜ì—¬ ì•„ë‘ì´ë…¸ ëª…ë ¹ì–´ë¡œ ë³€í™˜
        arduino_command = "stop"  # ê¸°ë³¸ê°’ì€ ì •ì§€

        if "[PHASE 1]" in decision:
            arduino_command = "forward"
        elif "[PHASE 2]" in decision:
            arduino_command = "backward"

        print(f"[AI] Decision: {decision}")
        print(f"[AI] -> Mapped to Arduino Command: {arduino_command}")

        # (4) (ì¶”ê°€) ì•„ë‘ì´ë…¸ë¡œ ëª…ë ¹ì–´ ì „ì†¡
        send_command(ser, arduino_command)

        # (5) (ì¶”ê°€) ì°¨ëŸ‰ì´ ì›€ì§ì¼ ì‹œê°„ ëŒ€ê¸°
        print(f"[System] {TIME_PER_HOUR_SEC}ì´ˆ ë™ì•ˆ ì°¨ëŸ‰ ë™ì‘ ìˆ˜í–‰...")
        time.sleep(TIME_PER_HOUR_SEC)

        # (6) (ì¶”ê°€) ë‹¤ìŒ ì‹œê°„ì„ ìœ„í•´ ì°¨ëŸ‰ ì •ì§€ (ì„ íƒ ì‚¬í•­ì´ì§€ë§Œ ì•ˆì „í•¨)
        if arduino_command != "stop":
            send_command(ser, "stop")
            print("[System] ë‹¤ìŒ ì‹œê°„ ì‹œë®¬ë ˆì´ì…˜ì„ ìœ„í•´ ì°¨ëŸ‰ ì •ì§€")

        # --- ê¸°ì¡´ ë¡œê·¸ ì €ì¥ ë¡œì§ ---
        net_profit = (ch_profit + profit) - ch_cost
        cum_profit += net_profit
        logs.append({
            "hour": hour, "B_load_kWh": b_load, "SMP_price": smp,
            "surplus_kWh": surplus, "decision": decision,
            "charge_action": charge_action, "ess_soc(%)": round(system.ess_soc, 2),
            "h2_storage(%)": round(system.h2_storage, 2), "revenue_won": round(revenue, 0),
            "cost_won": round(ch_cost + cost, 0), "profit_won": round(net_profit, 0),
            "cum_profit_won": round(cum_profit, 0)
        })

    print("\n--- 24ì‹œê°„ ì‹œë®¬ë ˆì´ì…˜ ë° ì œì–´ ì™„ë£Œ ---")

except serial.SerialException as e:
    print(f"\n[Arduino] ì˜¤ë¥˜: {BLUETOOTH_PORT} í¬íŠ¸ì— ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    print(f"ìƒì„¸ ì •ë³´: {e}")
    print("1. HC-05ê°€ PCì™€ í˜ì–´ë§ë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.")
    print("2. COM í¬íŠ¸ ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥¸ì§€ í™•ì¸í•˜ì„¸ìš”.")
    print("3. ì•„ë‘ì´ë…¸ì— ì „ì›ì´ ì¼œì ¸ ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.")

except KeyboardInterrupt:
    print("\n[System] ì‚¬ìš©ìì— ì˜í•´ í”„ë¡œê·¸ë¨ì´ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.")

finally:
    # --- (ì¶”ê°€) ìŠ¤í¬ë¦½íŠ¸ ì¢…ë£Œ ì‹œ ì•„ë‘ì´ë…¸ ì—°ê²° í•´ì œ ë° ì •ì§€ ---
    if ser and ser.is_open:
        print("[Arduino] ëª¨ë“  ì‘ì—…ì„ ì¢…ë£Œí•˜ê³  ì°¨ëŸ‰ì„ ì •ì§€í•©ë‹ˆë‹¤.")
        send_command(ser, "stop")
        ser.close()
        print("[Arduino] ì—°ê²°ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.")
    else:
        print("\n[Arduino] ì—°ê²°ì´ ì‹œì‘ë˜ì§€ ì•Šì•˜ê±°ë‚˜ ì´ë¯¸ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")

# ===== 5) ê²°ê³¼ ì €ì¥ & ìš”ì•½ =====
# (ê¸°ì¡´ ì½”ë“œì™€ ë™ì¼, ì‹œë®¬ë ˆì´ì…˜ì´ ëë‚˜ë©´ ì—‘ì…€ íŒŒì¼ ì €ì¥)
if logs:  # ë¡œê·¸ê°€ í•˜ë‚˜ë¼ë„ ìˆì–´ì•¼ ì‹¤í–‰
    result = pd.DataFrame(logs)

    OUT_XLSX = "AI_Daily_Operation_Log_new.xlsx"
    OUT_CSV = "AI_Daily_Operation_Log_new.csv"
    result.to_excel(OUT_XLSX, index=False)
    result.to_csv(OUT_CSV, index=False, encoding="utf-8-sig")

    print(f"\nğŸ’¾ ê²°ê³¼ ì €ì¥ ì™„ë£Œ: {OUT_XLSX}, {OUT_CSV}")
    print(result.head(10)[["hour", "decision", "revenue_won", "cost_won", "profit_won"]])

    summary = result["decision"].value_counts()
    print("\n=== ì˜ì‚¬ê²°ì • ìš”ì•½ ===")
    for k, v in summary.items():
        print(f"{k}: {v}ì‹œê°„")

    phase2_hours = result.loc[result["decision"].str.contains("PHASE 2", na=False), "hour"].tolist()
    print("\nPHASE 2 ë°œìƒ ì‹œê°:", phase2_hours if phase2_hours else "ì—†ìŒ")
    print("ì´ ëˆ„ì  ì´ìµ(ì›):", int(result["cum_profit_won"].iloc[-1]))
else:
    print("\n[System] ì‹œë®¬ë ˆì´ì…˜ ë¡œê·¸ê°€ ì—†ì–´ ê²°ê³¼ íŒŒì¼ì„ ì €ì¥í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
